#ifndef INCLUDED_INPUT_EVENT_H
#define INCLUDED_INPUT_EVENT_H
#include "input/Keycodes.h"
#include "core/lxEvent.h"

namespace lux
{
namespace input
{
class InputDevice;

//! From where a event was sent
enum class EEventSource
{
	Mouse, //!< The event was generated by the mouse 
	Keyboard, //!< The event was generated by the keyboard
	Joystick, //!< The event was generated by a joystick.
};

//! What action generated an event
enum class EEventType
{
	//! A event was generated by changing a axis
	/*
	A linear value was changed
	*/
	Axis,

	//! A event was generated by changing a area
	/**
	A two dimensional value was changed
	*/
	Area,

	//! A event was generated by changing the state of a button
	/**
	A boolean value was changed
	*/
	Button
};

enum class EElementType // Flag class
{
	Input = 0x1,
	Output = 0x2,
	Axis = 0x4,
	Button = 0x8,
	Abs = 0x10,
	Rel = 0x20,
	PushButton = 0x40,
	ToggleButton = 0x80,
	POV = 0x100,
	ForceFeedback = 0x200,
	Area = 0x400,
	Other = 0x800
};

//! An single event for the user
class Event : public core::Event
{
public:
	//! General data about input events, available for all input events
	struct BaseInput
	{
		int code; //!< The element id of the activated input element.
	};

	//! data for button changes
	struct ButtonInput
	{
		EKeyCode code;               //!< The element id of the changed button.
		bool     pressedDown;   //!< Was the button pressed(True) or released(False)
		bool     state;    //!< Is the button currently down(true) or up(false).
	};

	//! data for axis changes
	struct AxisInput
	{
		EAxisCode code;       //!< What axis changed
		float abs;              //!< The new absolute value of the axis
		float rel;              //!< The relative movement of the axis
	};

	//! data for area changes
	struct AreaInput
	{
		EAreaCode code;    //!< What area changed
		float absX;          //!< The new absolute value of the x subaxis
		float relX;          //!< The relative change of the x subaxis
		float absY;          //!< The new absolute value of the y subaxis
		float relY;          //!< The relative change of the y subaxis
	};

	//! Inputdata from the mouse
	struct MouseInput
	{};

	//! Inputdata from the keyboard
	struct KeyboardInput
	{
		u32 character[4]; //!< The charcter generated by pressing the last button
	};

	bool shift : 1; //!< True if shift was hold during the event
	bool control : 1; //!< True if control was hold during the event

	bool internal_abs_only : 1; //!< For internal use
	bool internal_rel_only : 1; //!< For internal use

	EEventType type; //!< The type of the event
	EEventSource source; //!< The source of the event
	InputDevice* device; //!< The input device which send the message, can be null.
	union
	{
		struct MouseInput mouseInput; //!< Mouseinput data, use when eventSource equals EES_MOUSE_EVENT
		struct KeyboardInput keyInput; //!< Keyinput data, use when eventSource equals EES_KEYBOARD_EVENT
	};

	union
	{
		struct BaseInput base; //! BaseInput data, use when eventType is a input device.
		struct ButtonInput button; //!< ButtonEventData, use when eventType equals EET_BUTTON
		struct AxisInput axis; //!< AxisEventData, use when eventType equals EET_AXIS
		struct AreaInput area; //!< AreaEventData, use when eventType equals EET_AREA
	};
};

class EventHandler
{
public:
	virtual ~EventHandler() {}
	virtual void OnEvent(const input::Event& e)
	{
		if(e.source == input::EEventSource::Keyboard && e.type == input::EEventType::Button)
			OnKey(e.button.pressedDown, e.button.code, e);
		if(e.source == input::EEventSource::Mouse && e.type == input::EEventType::Button) {
			if(e.button.code == input::EKeyCode::KEY_LBUTTON)
				OnLButton(e.button.pressedDown, e);
			if(e.button.code == input::EKeyCode::KEY_RBUTTON)
				OnRButton(e.button.pressedDown, e);
		}
		if(e.source == input::EEventSource::Mouse && e.type == input::EEventType::Area) {
			OnMouseMove(math::Vector2F(e.area.relX, e.area.relY), e);
		}
		if(e.source == input::EEventSource::Mouse && e.type == input::EEventType::Axis) {
			if(e.axis.code == input::EAxisCode::AXIS_MOUSE_WHEEL)
				OnMouseWheel(e.axis.rel, e);
		}
	}

	virtual void OnLButton(bool isDown, const input::Event& event) { LUX_UNUSED(isDown); LUX_UNUSED(event); }
	virtual void OnRButton(bool isDown, const input::Event& event) { LUX_UNUSED(isDown); LUX_UNUSED(event); }
	virtual void OnMouseMove(const math::Vector2F& move, const input::Event& event) { LUX_UNUSED(move); LUX_UNUSED(event); }
	virtual void OnMouseWheel(float move, const input::Event& event) { LUX_UNUSED(move); LUX_UNUSED(event); }

	virtual void OnKey(bool isDown, input::EKeyCode key, const input::Event& event) { LUX_UNUSED(isDown); LUX_UNUSED(key); LUX_UNUSED(event); }
};

} // namespace input
DECLARE_FLAG_CLASS(input::EElementType);
} // namespace lux


#endif