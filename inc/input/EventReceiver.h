#ifndef INCLUDED_EVENTRECEIVER_H
#define INCLUDED_EVENTRECEIVER_H
#include "Keycodes.h"
#include "core/ReferenceCounted.h"

namespace lux
{
namespace input
{
class InputDevice;

//! From where a event was sent
enum class EEventSource
{
	Gui, //!< The event was generated by the graphical user interface
	Mouse, //!< The event was generated by the mouse 
	Keyboard, //!< The event was generated by the keyboard
	Joystick, //!< The event was generated by a joystick.
};

//! Where should the event be send
enum class EEventTarget
{
	User = 0x01,
	Scene = 0x02,
	Gui = 0x04,

	All = User | Scene | Gui,
};

//! What action generated an event
enum class EEventType : u32
{
	//! A event was generated by changing a axis
	/*
	A linear value was changed
	*/
	Axis,

	//! A event was generated by changing a area
	/**
	A two dimensional value was changed
	*/
	Area,

	//! A event was generated by changing the state of a button
	/**
	A boolean value was changed
	*/
	Button
};

enum class EElementType // Flag class
{
	Input = 0x1,
	Output = 0x2,
	Axis = 0x4,
	Button = 0x8,
	Abs = 0x10,
	Rel = 0x20,
	PushButton = 0x40,
	ToggleButton = 0x80,
	POV = 0x100,
	ForceFeedback = 0x200,
	Area = 0x400,
	Other = 0x800
};

//! An single event for the user
class Event
{
public:
	//! General data about input events, available for all input events
	struct BaseInput
	{
		u32 code; //!< The element id of the activated input element.
	};

	//! data for button changes
	struct ButtonInput
	{
		EKeyCode code;               //!< The element id of the changed button.
		bool     pressedDown;   //!< Was the button pressed(True) or released(False)
		bool     state;    //!< Is the button currently down(true) or up(false).
	};

	//! data for axis changes
	struct AxisInput
	{
		EAxisCode code;       //!< What axis changed
		int abs;              //!< The new absolute value of the axis
		int rel;              //!< The relative movement of the axis
	};

	//! data for area changes
	struct AreaInput
	{
		EAreaCode code;    //!< What area changed
		int absX;          //!< The new absolute value of the x subaxis
		int relX;          //!< The relative change of the x subaxis
		int absY;          //!< The new absolute value of the y subaxis
		int relY;          //!< The relative change of the y subaxis
	};

	//! Inputdata from the mouse
	struct MouseInput
	{};

	//! Inputdata from the keyboard
	struct KeyboardInput
	{
		wchar_t character[4]; //!< The charcter generated by pressing the last button
	};

	bool shift : 1; //!< True if shift was hold during the event
	bool control : 1; //!< True if control was hold during the event
	bool internal_abs_only : 1; //!< For internal use
	bool internal_rel_only : 1; //!< For internal use

	EEventType type; //!< The type of the event
	EEventSource source; //!< The source of the event
	InputDevice* device; //!< The input device which send the message, can be null.
	union
	{
		struct MouseInput mouseInput; //!< Mouseinput data, use when eventSource equals EES_MOUSE_EVENT
		struct KeyboardInput keyInput; //!< Keyinput data, use when eventSource equals EES_KEYBOARD_EVENT
	};

	union
	{
		struct BaseInput base; //! BaseInput data, use when eventType is a input device.
		struct ButtonInput button; //!< ButtonEventData, use when eventType equals EET_BUTTON
		struct AxisInput axis; //!< AxisEventData, use when eventType equals EET_AXIS
		struct AreaInput area; //!< AreaEventData, use when eventType equals EET_AREA
	};
};

//! An event receiver
/**
Every time the engine generates a event OnEvent is called
You can register your eventreceiver with LuxDevice::SetUserEventReceiver
or GUIEnvironment::SetUserEventReceiver
or use one of the many interfaces which implements this interface
See the respective documentation to learn more
*/
class EventReceiver
{
public:
	virtual ~EventReceiver()
	{
	}

	//! Split the path of a event
	/**
	Depending on the value of the event, one of the other receiver methods is called,
	i.e. OnKeyDown, OnKeyUp, OnMouseMove etc.
	*/
	virtual bool SplitEvent(const Event& event)
	{
		if(event.source == EEventSource::Keyboard) {
			if(event.type == EEventType::Button) {
				if(event.button.pressedDown)
					return OnKeyDown(event.button.code, event);
				else
					return OnKeyUp(event.button.code, event);
			}
		}

		if(event.source == EEventSource::Mouse) {
			if(event.type == EEventType::Button) {
				if(event.button.pressedDown)
					return OnMouseKeyDown(event.button.code, event);
				else
					return OnMouseKeyUp(event.button.code, event);
			}
			if(event.type == EEventType::Area) {
				return OnMouseMove(event.area.relX, event.area.relY, event);
			}

			if(event.type == EEventType::Axis) {
				if(event.axis.code == AXIS_MOUSE_WHEEL)
					return OnMouseWheel(event.axis.rel, event);
				if(event.axis.code == AXIS_MOUSE_HWHEEL)
					return OnMouseHWheel(event.axis.rel, event);
			}
		}

		if(event.source == EEventSource::Joystick)
			return OnJoystick(event);

		return OnUnknownEvent(event);
	}

	//! This is called for each event
	/**
	\param event The newly generated event
	\return Return true to signal that the event is fully handled
	it then is _not_ handed to the next receiver
	*/
	virtual bool OnEvent(const Event& event)
	{
		return SplitEvent(event);
	}

	virtual bool OnKeyDown(EKeyCode keyCode, const Event& event) { LUX_UNUSED(keyCode); LUX_UNUSED(event); return false; }
	virtual bool OnKeyUp(EKeyCode keyCode, const Event& event) {  LUX_UNUSED(keyCode); LUX_UNUSED(event); return false; }
	virtual bool OnMouseKeyDown(EKeyCode keyCode, const Event& event) { LUX_UNUSED(keyCode); LUX_UNUSED(event); return false; }
	virtual bool OnMouseKeyUp(EKeyCode keyCode, const Event& event) { LUX_UNUSED(keyCode); LUX_UNUSED(event); return false; }
	virtual bool OnMouseMove(int x, int y, const Event& event) { LUX_UNUSED(x); LUX_UNUSED(y); LUX_UNUSED(event); return false; }
	virtual bool OnMouseWheel(int move, const Event& event) { LUX_UNUSED(move); LUX_UNUSED(event); return false; }
	virtual bool OnMouseHWheel(int move, const Event& event) { LUX_UNUSED(move); LUX_UNUSED(event); return false; }
	virtual bool OnJoystick(const Event& event) { LUX_UNUSED(event); return false; }
	virtual bool OnUnknownEvent(const Event& event) { LUX_UNUSED(event); return false; }
};

//! An event receiver
/**
Every time the engine generates a event OnEvent is called
You can register your eventreceiver with LuxDevice::SetUserEventReceiver
or GUIEnvironment::SetUserEventReceiver
or use one of the many interfaces which implements this interface
See the respective documentation to learn more
*/
class UserEventReceiver : public EventReceiver, public ReferenceCounted
{
public:
	virtual ~UserEventReceiver()
	{
	}
};

}

DECLARE_FLAG_CLASS(input::EEventTarget);
DECLARE_FLAG_CLASS(input::EElementType);
}


#endif